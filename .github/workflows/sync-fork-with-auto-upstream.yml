name: 一键自动同步 Fork 仓库（自动检测源仓库 + 代码 + Tags + Releases + 附件）

on:
  workflow_dispatch:   # 手动触发，推荐
  # schedule:
  #   - cron: '0 0 * * *'  # 可选：每天自动同步

jobs:
  sync-fork:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      # ----------------------------------------------
      # Step 1: 获取当前仓库信息，并查询上游（源）仓库
      # ----------------------------------------------
      - name: Get current repository info
        id: repo_info
        run: |
          echo "当前仓库: ${{ github.repository }}"
          echo "仓库所有者: ${{ github.repository_owner }}"
          echo "仓库名称: ${{ github.event.repository.name }}"

          # 调用 GitHub API 获取当前仓库的详细信息，包括是否是 Fork 以及它的父仓库（源仓库）
          REPO_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }})

          IS_FORK=$(echo "$REPO_INFO" | jq -r '.fork')
          if [ "$IS_FORK" != "true" ]; then
            echo "❌ 当前仓库不是 Fork 仓库，无法自动检测源仓库。"
            echo "✅ 请确认你已手动 Fork 了某个上游仓库。"
            exit 1
          fi

          UPSTREAM_FULL_NAME=$(echo "$REPO_INFO" | jq -r '.parent.full_name')
          echo "检测到源仓库（上游）: $UPSTREAM_FULL_NAME"

          # 设置输出变量，供后续步骤使用
          echo "upstream_full_name=$UPSTREAM_FULL_NAME" >> $GITHUB_OUTPUT
          echo "target_repo=${{ github.repository }}" >> $GITHUB_OUTPUT

      # ----------------------------------------------
      # Step 2: Checkout 你的 Fork 仓库
      # ----------------------------------------------
      - name: Checkout your fork
        uses: actions/checkout@v4
        with:
          ref: master
          token: ${{ secrets.MY_GIT_TOKEN }}  # 你的个人 Token，需要有 repo 权限
          fetch-depth: 0

      - name: Set Git Identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # ----------------------------------------------
      # Step 3: 获取源仓库信息并设置远程
      # ----------------------------------------------
      - name: Add upstream remote (源仓库)
        run: |
          UPSTREAM_REPO=${{ steps.repo_info.outputs.upstream_full_name }}
          echo "添加远程源仓库: $UPSTREAM_REPO"
          git remote add upstream https://github.com/$UPSTREAM_REPO.git

      - name: Fetch upstream（代码 + Tags）
        run: |
          git fetch upstream --tags

      - name: Push all tags to your fork
        run: |
          git push origin --tags

      - name: Merge upstream/master
        run: |
          git merge upstream/master --allow-unrelated-histories -X theirs || echo "Already up-to-date or no changes"

      - name: Push code to your fork
        run: |
          git remote set-url origin https://${{ secrets.MY_GIT_TOKEN }}@github.com/${{ github.repository }}.git
          git push origin master

      # ----------------------------------------------
      # Step 4: 同步 Releases 和附件
      # ----------------------------------------------
      - name: Sync Releases and Assets using GitHub API
        env:
          SOURCE_REPO: ${{ steps.repo_info.outputs.upstream_full_name }}
          TARGET_REPO: ${{ steps.repo_info.outputs.target_repo }}
          GITHUB_TOKEN: ${{ secrets.MY_GIT_TOKEN }}  # 或者使用 secrets.GITHUB_TOKEN（但权限可能不足）
        run: |
          echo "🔁 开始同步 Releases 和附件"
          echo "📥 源仓库（上游）: $SOURCE_REPO"
          echo "📤 目标仓库（你的 Fork）: $TARGET_REPO"

          # 获取源仓库的所有 Releases
          RELEASES=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            https://api.github.com/repos/$SOURCE_REPO/releases)

          # 检查是否成功获取 Releases 列表
          echo "$RELEASES" | jq -e 'type == "array"' >/dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "❌ 获取 Releases 失败，返回内容可能不是有效的数组或 API 出错。"
            echo "返回的原始内容："
            echo "$RELEASES"
            exit 1
          fi

          # 遍历每一个 Release
          echo "$RELEASES" | jq -c '.[]' | while read -r release; do
            TAG_NAME=$(echo "$release" | jq -r '.tag_name')
            NAME=$(echo "$release" | jq -r '.name')
            BODY=$(echo "$release" | jq -r '.body')
            DRAFT=$(echo "$release" | jq -r '.draft')
            PRERELEASE=$(echo "$release" | jq -r '.prerelease')
            RELEASE_ID_ORIGINAL=$(echo "$release" | jq -r '.id')

            echo "🔁 正在处理 Release: $NAME (Tag: $TAG_NAME)"

            # Step 1: 在你的 Fork 中创建相同的 Release
            echo "🆕 在你的 Fork 中创建 Release: $NAME"
            CREATED_RELEASE=$(curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/$TARGET_REPO/releases \
              -d '{
                "tag_name": "'"$TAG_NAME"'",
                "name": "'"$NAME"'",
                "body": "'"$BODY"'",
                "draft": '$DRAFT',
                "prerelease": '$PRERELEASE'
              }')

            # 检查是否创建成功
            echo "$CREATED_RELEASE" | jq -e 'has("id")' >/dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "❌ 创建 Release 失败，返回内容："
              echo "$CREATED_RELEASE"
              echo "⏩ 跳过此 Release 的附件同步"
              continue
            fi

            # 获取创建的 Release 的 upload_url 和 id
            UPLOAD_URL=$(echo "$CREATED_RELEASE" | jq -r '.upload_url' | sed 's/{?name,label}//')
            RELEASE_ID=$(echo "$CREATED_RELEASE" | jq -r '.id')

            echo "✅ 创建成功！Release ID: $RELEASE_ID"
            echo "📤 Upload URL Base: $UPLOAD_URL"

            # Step 2: 获取该 Release 的所有附件（Assets）
            ASSETS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              https://api.github.com/repos/$SOURCE_REPO/releases/$RELEASE_ID_ORIGINAL/assets)

            echo "$ASSETS" | jq -c '.[]' | while read -r asset; do
              ASSET_NAME=$(echo "$asset" | jq -r '.name')
              ASSET_URL=$(echo "$asset" | jq -r '.url')
              ASSET_ID=$(echo "$asset" | jq -r '.id')
              CONTENT_TYPE=$(echo "$asset" | jq -r '.content_type')
              DOWNLOAD_URL=$(echo "$asset" | jq -r '.browser_download_url')

              echo "⬇️  正在下载附件: $ASSET_NAME"

              # 下载附件到临时目录
              curl -s -L -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/octet-stream" \
                "$DOWNLOAD_URL" -o "/tmp/$ASSET_NAME"

              # 上传附件到你的 Fork 的 Release
              echo "📤 正在上传附件: $ASSET_NAME 到 Release ID $RELEASE_ID"
              UPLOAD_RESPONSE=$(curl -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Content-Type: $CONTENT_TYPE" \
                --data-binary @"/tmp/$ASSET_NAME" \
                "${UPLOAD_URL}?name=${ASSET_NAME}" 2>&1)

              if echo "$UPLOAD_RESPONSE" | grep -q "201 Created"; then
                echo "✅ 附件上传成功: $ASSET_NAME"
              else
                echo "❌ 附件上传失败: $ASSET_NAME"
                echo "错误详情："
                echo "$UPLOAD_RESPONSE"
              fi

              # 清理临时文件
              rm -f "/tmp/$ASSET_NAME"

              echo "--------------------------------------------------"
            done

          done

          echo "🎉 所有 Releases 和附件同步完成！"
